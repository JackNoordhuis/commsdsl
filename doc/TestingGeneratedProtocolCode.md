# Testing Generated Protocol Code

The **commsdsl2test** utility generates a full CMake project, which can be used to test the
generated protocol code. Fuzz testing with [AFL](http://lcamtuf.coredump.cx/afl/) is 
also supported. 

Note that the CMake project generated by the **commsdsl2test** utility requires the 
protocol definition code generated by the **commsdsl2comms** utility.

If you take a look inside the major CMakeLists.txt file of the generated project you'll see
all the configuration options and other variables listed at the top of the file.

```
option (OPT_WARN_AS_ERR "Treat warning as error" ON)
option (OPT_USE_CCACHE "Use of ccache on UNIX system" ON)
# Other parameters:
# OPT_TEST_OPTIONS - Class name of the options for test applications,
#       defaults to test1::options::DefaultOptions.
# OPT_TEST_INTERFACE - Class name of the interface for test applications,
#       defaults to test1::Message.
# OPT_TEST_FRAME - Class name of the frame for test applications,
#       defaults to test1::frame::Frame.
# OPT_TEST_INPUT_MESSAGES - All input messages bundle for test applications,
#       defaults to test1::input::AllMessages.
# OPT_MSVC_FORCE_WARN_LEVEL - Force msvc warning level
```

Using the cmake parameters listed above it is possible to specify the right configuration of 
the protocol to be tested.

Note that the main generated CMakeLists.txt file uses `find_package()` to locate
both [COMMS Library](https://github.com/commschamp/comms) and the generated protocol.

```
find_package (LibComms REQUIRED)
find_package (test1 REQUIRED)
```

Please use **CMAKE_PREFIX_PATH** cmake variable to specify the right paths:

```
cmake -DCMAKE_PREFIX_PATH="/path/to/comms/install;/path/to/protocol/install" ...
```

It is recommended to use non-release build configuration to have all the **assert()**
checks being active.

In case of AFL fuzz testing please use appropriate settings for instrumenting
compilers:
```
$> CC=afl-gcc CXX=afl-g++ cmake ...
```

The [AFL](http://lcamtuf.coredump.cx/afl/) requires having initial input to work
with. The simplest way is to create a single binary file with random input (even 
single 0 byte will do).
```
$> printf "\x00" > ./input/zero.bin
$> afl-fuzz -i ./input -o ./output ./demo1_input_test
```
It may take several minutes to [AFL](http://lcamtuf.coredump.cx/afl/) but
eventually it will be able to find binary data that leads to actual messages and 
exercising real messages and fields serialization.
