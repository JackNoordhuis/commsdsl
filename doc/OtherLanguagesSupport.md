# Other Languages Support

The [CommsChampion Ecosystem](https://commschamp.github.io/) is mostly about C++ and embedded systems. However,
other high level languages can also be supported by generation of the bindings (glue code) using
[SWIG](https://www.swig.org/). Please refer to the [documentation](https://www.swig.org/Doc4.0/SWIGDocumentation.html)
to make sure that the chosen target language is properly supported.

Also, to be able to properly use the protocol definition code in the target high level language the callbacks need to
be properly supported. [SWIG](https://www.swig.org/) calls this feature
[directors](https://www.swig.org/Doc4.0/SWIGDocumentation.html#SWIGPlus_target_language_callbacks). Please
make sure the selected target language supports this feature. Not all of them do.

In case [SWIG](https://www.swig.org/) doesn't support required target language, but the latter has its own
way to support C++ glue code, it's still beneficial to understand the way how [SWIG](https://www.swig.org/)
support is implemented. It can be used as a reference to define wrapping classes required for the target language
bindings.

The generation of the [SWIG](https://www.swig.org/) interface file(s) is performed using **commsdsl2swig** code
generation, please make sure its build is enabled by using appropriate cmake [options](../CMakeLists.txt).


## Build Order

- Generate the protocol definition files using **commsdsl2comms**.
- Properly build and install the generated protocol definition project. It will generate appropriate cmake config
  file allowing the protocol headers only library to be found using `find_package()`.
- Generate the swig bindings using **commsdsl2swig**. It generates CMakeLists.txt allowing the generated project being built
  separately, but some extra code injection may be required (explained later).
- Build the project generated by the **commsdsl2swig** providing relevant configuration (specifying the target language(s)).
  Use **CMAKE_PREFIX_PATH** to specify path to the installation directory of the protocol definition project.
- If applicable (for languages like Java or C#), perform extra compilation of the target language sources generated by the [swig](https://www.swig.org/).

Note that [swig](https://www.swig.org/) generates the following:

- C++ sources with bindings (glue code), which needs to be compiled as a shared library (.so/.dll).
- Target language wrapping sources, which use the glue code functions. They need to be compiled (if applicable) separately
  using target language compile, for example `javac` for Java.

Also note that bindings shared library needs to be properly loaded (if it's not done by the swig-generated integration code)
by the client side before they can be used.

For example in Java:
```java
public class MyProtocol {
    static {
        System.loadLibrary("my_protocol");
    }

    ...
}
```

For more details please refer to the language specific swig [documentation](https://www.swig.org/Doc4.0/SWIGDocumentation.html).

## Produced Output

- **include** folder - Contains header files with the declaration of the wrapper C++ classes, bindings for which need to be generated.
  Note that they are not real C++ code and not used by any C++ compiler. They are parsed by the [swig](https://www.swig.org/).
  However, the directory structure resembles the one produced by the **commsdsl2comms** for easy navigation. The developer
  should use these files to determine what functionality is available in the target language.
- **&lt;protocol_name&gt;.i** - [SWIG](https://www.swig.org/) interface file containing real C++ code of the binding classes definition
  as well as some swig directives specifying some extra functionality.
- **CMakeLists.txt** - CMake project definition file allowing output to be built as a separate project.


## Generated CMake Project
As it was mentioned earlier output of the **commsdsl2swig**
(like any other [commsdsl](https://github.com/commschamp/commsdsl) code generator) contains **CMakeLists.txt**.
It can be used to build it as a separate cmake project. Note that the generated **CMakeLists.txt** is
incomplete. Many target languages require external libraries for glue code. The comments inside the
generated **CMakeLists.txt** indicate what extra source files need to be used to inject extra modifications
to the file.

For example Python and Java support may require:

CMakeLists.txt.prepend:
```
find_package(Python3 REQUIRED COMPONENTS Development)
find_package(JNI REQUIRED)
find_package(Java REQUIRED COMPONENTS Runtime Development)
```

CMakeLists.txt.prepend_lang:
```
set (CMAKE_SWIG_FLAGS -Werror)
if ("${lang}" STREQUAL "python")
    list (APPEND CMAKE_SWIG_FLAGS -Wall)
elseif ("${lang}" STREQUAL "java")
    list (APPEND CMAKE_SWIG_FLAGS -Wall -package my_protocol_pkg)
endif ()
```

CMakeLists.txt.append:
```
target_link_libraries(my_protocol_swig_python Python3::Python)
target_link_libraries(my_protocol_swig_java JNI::JNI)

add_custom_target(
    my_protocol_swig_java_compile ALL
    COMMAND ${Java_JAVAC_EXECUTABLE} -Xdiags:verbose -d . ${CMAKE_CURRENT_BINARY_DIR}/*.java
    DEPENDS ${my_protocol_swig_java}
    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
)
```

Note that the generated **CMakeLists.txt** uses [swig_add_library()](https://cmake.org/cmake/help/latest/module/UseSWIG.html) cmake
function. It creates multiple targets, but the provided name is the created shared library of the glue code.
Also refer to the cmake [documentation](https://cmake.org/cmake/help/latest/module/UseSWIG.html) and use the
injected code to modify the default behavior if needed.

## Class Naming
In order to produce unified bindings code for all the languages (some of which may not include package / namespace feature), the
C++ scope of the class is flattened by replacing `::` with `_` and omitting the top level namespace by default.

For example:
```xml
<shema name="my_prot">
    <fields>
        <int name="F1" type="uint32" />
    <fields>

    <message name="Msg1" id="1">
        <ref field="F1" />
    </message>
</schema>
```
The generated class declaration files is going to reside in `include/my_prot/field/F1.h` and
`include/my_prot/message/Msg1.h`. The respective classes will be named `field_F1` and `message_Msg1`.

The classes are not prefixed with the protocol name namespace because the swig interface file names the whole
module with the protocol name.
```
%module(directors="1") my_prot;
```
Some of the target programming languages, like Python, automatically put the classes into the specified module and
they are referenced using the name:
```python
msg = my_prot.message_Msg1()
```
However, there are target languages, like Java or C#, that don't do it. To achieve the same effect it is recommended to
pass relevant options (`-package` for Java or `-namespace` for C#) to the swig invocation.

When there are [multiple different schema names](https://commschamp.github.io/commsdsl_spec/#intro-multiple-schemas) in
use, then all the generated classes are prefixed with the schema (protocol) name automatically to differentiate between them.

Also, the **commsdsl2swig** code generator has the `force-main-ns-in-names` command line option forcing the main namespace
prefixing of the generated classes.

## Raw Data Buffer
When dealing with raw data buffers, the binding C++ classes expect to work with `std::vector<unsigned char>`
(defined in `/include/DataBuf`). The [SWIG](https://www.swig.org/) generation is expected to generate appropriate
wrapper and/or translation functionality.

For example, in Python, it is possible to use
[bytearray](https://www.w3schools.com/python/ref_func_bytearray.asp), [list of ints](https://www.w3schools.com/python/python_lists.asp),
or [tuple of ints](https://www.w3schools.com/python/python_tuples.asp). The swig is expected to convert it
to the relevant vector automatically.

In Java, the `DataBuf` class is generated with one of the constructors defined as:
```java
public DataBuf(short[] initialElements) {...}
```

In C#, the `DataBuf` class is generated with the following constructors:
```csharp
public DataBuf(global::System.Collections.IEnumerable c) {...}
public DataBuf(global::System.Collections.Generic.IEnumerable<byte> c) {...}
```

## Message Handling
Following the same convention as with the protocol generated by the **commsdsl2comms** (unless the
protocol definition defines its own `<interface>`) the default interface class is named `Message` and
resides in `include/my_prot/Message.h`. The defined interface is polymorphic:
```cpp
class MsgHandler;

class Message
{
public:
    virtual ~Message();

    const char* name() const;
    MsgId getId() const;
    comms_ErrorStatus read(const DataBuf& buf);
    comms_ErrorStatus write(DataBuf& buf) const;
    bool refresh();
    unsigned long length() const;
    bool valid() const;
    void dispatch(MsgHandler& handler);
protected:
    Message();
    Message(const Message& other);
};
```

The `dispatch()` member function allows polymorphic dispatch to the handler object.

The `MsgHandler` is expected to define virtual handling member functions. Due to the fact that not all target
languages can have overloaded member functions with the same name, the name of the handling function is expected
to contain the message class name as well:
```cpp
class MsgHandler
{
public:
     virtual ~MsgHandler();

     virtual void handle_message_Msg1(message_Msg1& msg);
     virtual void handle_message_Msg2(message_Msg2& msg);

     virtual void handle_Message(Message& msg);
};
```
By default every `handle_message_X()` calls the interface invocation `handle_Message()`, which by default
does nothing. The extending class in the target language can override any of the necessary virtual functions.

For example in Python:
```python
class ClientMsgHandler(my_prot.MsgHandler):
    def __init__(self):
        my_prot.MsgHandler.__init__(self)

    def handle_message_Msg1(self, msg):
        ...

    def handle_Message(self, msg):
        sys.exit("shouldn't happen")
```
Or in Java:
```java
public class ClientMsgHandler extends my_prot_pkg.MsgHandler {
    ...
    public void handle_message_Msg1(my_prot_pkg.message_Msg1 msg) {
        ...
    }

    public void handle_Message(my_prot_pkg.Message msg) {
        assert false;
    }
}
```

## Working with Raw Data Input / Output

## Memory Management

## Working with Units

## Handling Variant Members

## Language Specific
