# Protocol Definition Debugging Tips
Sometimes the protocol definition code generated by the **commsdsl2comms** compiles fine, but doesn't work
quite right. The best way to debug such a problem is to introduce extra prints to the generated member functions.

Every generated message class has the following non-polymorphic member functions (details are in
[tutorial1](https://github.com/commschamp/cc_tutorial/tree/master/tutorials/tutorial1)) most of which are inherited from the
[comms::MessageBase](https://commschamp.github.io/comms_doc/classcomms_1_1MessageBase.html).

```cpp
class Msg1 : public comms::MessageBase<...>
{
    // Redefinition of the base class
    using Base = comms::MessageBase<...>;
public:
    template <typename TIter>
    comms::ErrorStatus doRead(TIter& iter, std::size_t len);

    template <typename TIter>
    comms::ErrorStatus doWrite(TIter& iter, std::size_t len) const;

    MsgIdType doGetId() const;

    std::size_t doLength() const;

    static const char* doName();

    bool doValid() const;

    bool doRefresh();
}
```

The **commsdsl2comms** allows custom code injection (see [manual](Manual_commsdsl2comms.md)). It is very
easy to temporarily create extra injection file that does extra logging. For example

my_prot/message/Msg1.h.read
```cpp
template <typename TIter>
comms::ErrorStatus doRead(TIter& iter, std::size_t len)
{
    // Print buffer before read;
    std::cout << "Msg1 read: " << std::hex;
    std::copy_n(iter, len, std::ostream_iterator<unsigned>(std::cout, " "));
    std::cout << std::dec << std::endl;

    // Execute actual read by invoking base class read operation
    auto fromIter = iter;
    auto es = Base::doRead(iter, len);
    std::cout << "Error Status: " << es << std::endl;
    std::cout << "Consumed bytes: " << std::distance(fromIter, iter) << std::endl;
    retun es;
}
```

Note that some extra includes for the extra code may be required. Injection of the include statements can
be performed using `.inc` file

my_prot/message/Msg1.h.inc
```cpp
#include <algorithm>
#include <iostream>
#include <iterator>
```

There can also be a case when the relevant function is not inherited from the base class, but explicitly
generated by the **commsdsl2comms**. In such case every attempt to inject the custom functionality
automatically renames the generated member function by adding `Orig` suffix to it, i.e. the
generated `doRead()` becomes `doReadOrig()`. It allows the injected code to use if needed.

my_prot/message/Msg1.h.read
```cpp
template <typename TIter>
comms::ErrorStatus doRead(TIter& iter, std::size_t len)
{
    ...
    es = doReadOrig(iter, len);
    ...
}
```

When it comes to fields, they have very similar interface (details are in
[tutorial2](https://github.com/commschamp/cc_tutorial/tree/master/tutorials/tutorial2)).

```cpp
class SomeField : public ...
{
    using Base = ...
public:
    ...
    template <typename TIter>
    comms::ErrorStatus read(TIter& iter, std::size_t len);

    tempalte <typename TIter>
    comms::ErrorStatus write(TIter& iter, std::size_t) const;

    std::size_t length() const;

    bool valid() const;

    bool refresh();

    static const char* name();
};
```

The public member functions can be overridden the same way and extra logging added. Note, that only global fields
allow extra code injection. The **commsdsl2comms** doesn't allow injection of the custom code to the
fields which are members of a `<message>`, `<interface>` or another field. To workaround this limitation, just
use `<ref>` fields as members referencing the relevant global field.

Adding extra logging into the message and fields decoding usually allows to discover 99% of the possible problems, there
is no real need to try to use the debugger and/or dive into the [COMMS Library](https://github.com/commschamp/comms) internals.
